// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"

	"github.com/iot-synergy/openned8-rpc/ent/activecodeinfo"
	"github.com/iot-synergy/openned8-rpc/ent/appinfo"
	"github.com/iot-synergy/openned8-rpc/ent/categoryinfo"
	"github.com/iot-synergy/openned8-rpc/ent/industryinfo"
	"github.com/iot-synergy/openned8-rpc/ent/sdkusage"
)

const errInvalidPage = "INVALID_PAGE"

const (
	listField     = "list"
	pageNumField  = "pageNum"
	pageSizeField = "pageSize"
)

type PageDetails struct {
	Page  uint64 `json:"page"`
	Size  uint64 `json:"size"`
	Total uint64 `json:"total"`
}

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

const errInvalidPagination = "INVALID_PAGINATION"

type ActiveCodeInfoPager struct {
	Order  activecodeinfo.OrderOption
	Filter func(*ActiveCodeInfoQuery) (*ActiveCodeInfoQuery, error)
}

// ActiveCodeInfoPaginateOption enables pagination customization.
type ActiveCodeInfoPaginateOption func(*ActiveCodeInfoPager)

// DefaultActiveCodeInfoOrder is the default ordering of ActiveCodeInfo.
var DefaultActiveCodeInfoOrder = Desc(activecodeinfo.FieldID)

func newActiveCodeInfoPager(opts []ActiveCodeInfoPaginateOption) (*ActiveCodeInfoPager, error) {
	pager := &ActiveCodeInfoPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultActiveCodeInfoOrder
	}
	return pager, nil
}

func (p *ActiveCodeInfoPager) ApplyFilter(query *ActiveCodeInfoQuery) (*ActiveCodeInfoQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// ActiveCodeInfoPageList is ActiveCodeInfo PageList result.
type ActiveCodeInfoPageList struct {
	List        []*ActiveCodeInfo `json:"list"`
	PageDetails *PageDetails      `json:"pageDetails"`
}

func (aci *ActiveCodeInfoQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...ActiveCodeInfoPaginateOption,
) (*ActiveCodeInfoPageList, error) {

	pager, err := newActiveCodeInfoPager(opts)
	if err != nil {
		return nil, err
	}

	if aci, err = pager.ApplyFilter(aci); err != nil {
		return nil, err
	}

	ret := &ActiveCodeInfoPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := aci.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		aci = aci.Order(pager.Order)
	} else {
		aci = aci.Order(DefaultActiveCodeInfoOrder)
	}

	aci = aci.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := aci.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type AppInfoPager struct {
	Order  appinfo.OrderOption
	Filter func(*AppInfoQuery) (*AppInfoQuery, error)
}

// AppInfoPaginateOption enables pagination customization.
type AppInfoPaginateOption func(*AppInfoPager)

// DefaultAppInfoOrder is the default ordering of AppInfo.
var DefaultAppInfoOrder = Desc(appinfo.FieldID)

func newAppInfoPager(opts []AppInfoPaginateOption) (*AppInfoPager, error) {
	pager := &AppInfoPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultAppInfoOrder
	}
	return pager, nil
}

func (p *AppInfoPager) ApplyFilter(query *AppInfoQuery) (*AppInfoQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// AppInfoPageList is AppInfo PageList result.
type AppInfoPageList struct {
	List        []*AppInfo   `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (ai *AppInfoQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...AppInfoPaginateOption,
) (*AppInfoPageList, error) {

	pager, err := newAppInfoPager(opts)
	if err != nil {
		return nil, err
	}

	if ai, err = pager.ApplyFilter(ai); err != nil {
		return nil, err
	}

	ret := &AppInfoPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := ai.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		ai = ai.Order(pager.Order)
	} else {
		ai = ai.Order(DefaultAppInfoOrder)
	}

	ai = ai.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := ai.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type CategoryInfoPager struct {
	Order  categoryinfo.OrderOption
	Filter func(*CategoryInfoQuery) (*CategoryInfoQuery, error)
}

// CategoryInfoPaginateOption enables pagination customization.
type CategoryInfoPaginateOption func(*CategoryInfoPager)

// DefaultCategoryInfoOrder is the default ordering of CategoryInfo.
var DefaultCategoryInfoOrder = Desc(categoryinfo.FieldID)

func newCategoryInfoPager(opts []CategoryInfoPaginateOption) (*CategoryInfoPager, error) {
	pager := &CategoryInfoPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultCategoryInfoOrder
	}
	return pager, nil
}

func (p *CategoryInfoPager) ApplyFilter(query *CategoryInfoQuery) (*CategoryInfoQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// CategoryInfoPageList is CategoryInfo PageList result.
type CategoryInfoPageList struct {
	List        []*CategoryInfo `json:"list"`
	PageDetails *PageDetails    `json:"pageDetails"`
}

func (ci *CategoryInfoQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...CategoryInfoPaginateOption,
) (*CategoryInfoPageList, error) {

	pager, err := newCategoryInfoPager(opts)
	if err != nil {
		return nil, err
	}

	if ci, err = pager.ApplyFilter(ci); err != nil {
		return nil, err
	}

	ret := &CategoryInfoPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := ci.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		ci = ci.Order(pager.Order)
	} else {
		ci = ci.Order(DefaultCategoryInfoOrder)
	}

	ci = ci.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := ci.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type IndustryInfoPager struct {
	Order  industryinfo.OrderOption
	Filter func(*IndustryInfoQuery) (*IndustryInfoQuery, error)
}

// IndustryInfoPaginateOption enables pagination customization.
type IndustryInfoPaginateOption func(*IndustryInfoPager)

// DefaultIndustryInfoOrder is the default ordering of IndustryInfo.
var DefaultIndustryInfoOrder = Desc(industryinfo.FieldID)

func newIndustryInfoPager(opts []IndustryInfoPaginateOption) (*IndustryInfoPager, error) {
	pager := &IndustryInfoPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultIndustryInfoOrder
	}
	return pager, nil
}

func (p *IndustryInfoPager) ApplyFilter(query *IndustryInfoQuery) (*IndustryInfoQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// IndustryInfoPageList is IndustryInfo PageList result.
type IndustryInfoPageList struct {
	List        []*IndustryInfo `json:"list"`
	PageDetails *PageDetails    `json:"pageDetails"`
}

func (ii *IndustryInfoQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...IndustryInfoPaginateOption,
) (*IndustryInfoPageList, error) {

	pager, err := newIndustryInfoPager(opts)
	if err != nil {
		return nil, err
	}

	if ii, err = pager.ApplyFilter(ii); err != nil {
		return nil, err
	}

	ret := &IndustryInfoPageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := ii.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		ii = ii.Order(pager.Order)
	} else {
		ii = ii.Order(DefaultIndustryInfoOrder)
	}

	ii = ii.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := ii.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}

type SdkUsagePager struct {
	Order  sdkusage.OrderOption
	Filter func(*SdkUsageQuery) (*SdkUsageQuery, error)
}

// SdkUsagePaginateOption enables pagination customization.
type SdkUsagePaginateOption func(*SdkUsagePager)

// DefaultSdkUsageOrder is the default ordering of SdkUsage.
var DefaultSdkUsageOrder = Desc(sdkusage.FieldID)

func newSdkUsagePager(opts []SdkUsagePaginateOption) (*SdkUsagePager, error) {
	pager := &SdkUsagePager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultSdkUsageOrder
	}
	return pager, nil
}

func (p *SdkUsagePager) ApplyFilter(query *SdkUsageQuery) (*SdkUsageQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// SdkUsagePageList is SdkUsage PageList result.
type SdkUsagePageList struct {
	List        []*SdkUsage  `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

func (su *SdkUsageQuery) Page(
	ctx context.Context, pageNum uint64, pageSize uint64, opts ...SdkUsagePaginateOption,
) (*SdkUsagePageList, error) {

	pager, err := newSdkUsagePager(opts)
	if err != nil {
		return nil, err
	}

	if su, err = pager.ApplyFilter(su); err != nil {
		return nil, err
	}

	ret := &SdkUsagePageList{}

	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	count, err := su.Clone().Count(ctx)

	if err != nil {
		return nil, err
	}

	ret.PageDetails.Total = uint64(count)

	if pager.Order != nil {
		su = su.Order(pager.Order)
	} else {
		su = su.Order(DefaultSdkUsageOrder)
	}

	su = su.Offset(int((pageNum - 1) * pageSize)).Limit(int(pageSize))
	list, err := su.All(ctx)
	if err != nil {
		return nil, err
	}
	ret.List = list

	return ret, nil
}
